// INFO: Parametes section (URLs).
:pki_url_nice_label: https://en.wikipedia.org/wiki/Public_key_infrastructure[Public-key infrastructure (PKI)]

:pub_key_cert_nice_label: https://en.wikipedia.org/wiki/Public_key_certificate[Public-key certificate]

:hunspell_url_nice_label: https://en.wikipedia.org/wiki/Hunspell[Hunspell]

:pub_key_crypto_url_nice_label: https://en.wikipedia.org/wiki/Public-key_cryptography[Public-key cryptography]

:vscode_url_nice_label: https://en.wikipedia.org/wiki/Visual_Studio_Code[Visual Studio Code]

:asciidoctor_plantuml_url_nice_label: https://github.com/hsanson/asciidoctor-plantuml?tab=readme-ov-file#docker[PlantUML Server]

:docker_url_nice_label: https://en.wikipedia.org/wiki/Docker_(software)[Docker]

:computer_security_url_nice_label: https://en.wikipedia.org/wiki/Computer_security[Computer security]

:nsc_url_nice_label: https://www.gov.pl/web/baza-wiedzy/narodowe-standardy-cyber[Polish National Cybersecurity Standards]

:nsc_800_52_url_nice_label: https://www.gov.pl/attachment/e3804a73-2d3e-4232-bc6d-9bbb4ba697bb[Guidelines for the Selection, Configuration, and Use of Transport Layer Security (TLS) Implementations called NSC 800-52 published on December 2023]

:nist_url_nice_label: https://www.nist.gov[National Institute of Standards and Technology]

:nist_800_52_url_nice_label: https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-52r2.pdf[Guidelines for the Selection, Configuration, and Use of Transport Layer Security (TLS) Implementations called NIST Special Publication 800-52 Revision 2 published in August 2019]

:tls_url_nice_label: https://en.wikipedia.org/wiki/Transport_Layer_Security[Transport Layer Security (TLS)]

:crypt_protocol_url_nice_label: https://en.wikipedia.org/wiki/Cryptographic_protocol[Cryptographic protocol]

:comm_protocol_url_nice_label: https://en.wikipedia.org/wiki/Communication_protocol[Communication protocol]

:cryptography_url_nice_label: https://en.wikipedia.org/wiki/Cryptography[Cryptography]

:presentation_layer_url_nice_label: https://en.wikipedia.org/wiki/Presentation_layer[Presentation layer]

:handshake_url_nice_label: https://en.wikipedia.org/wiki/Handshake_(computing)[Handshake]

:ca_url_nice_label: https://en.wikipedia.org/wiki/Certificate_authority[Certificate authority]

:x509_url_nice_label: https://en.wikipedia.org/wiki/X.509[X.509]

:digital_signature_url_nice_label: https://en.wikipedia.org/wiki/Digital_signature[Digital signature]

:trusted_third_party_url_nice_label: https://en.wikipedia.org/wiki/Trusted_third_party[Trusted third party]

:vpn_url_nice_label: https://en.wikipedia.org/wiki/Virtual_private_network[Virtual private network (VPN)]

:https_url_nice_label: https://en.wikipedia.org/wiki/HTTPS[Hypertext Transfer Protocol Secure (HTTPS)]

:rest_url_nice_label: https://en.wikipedia.org/wiki/REST[Representational State Transfer (REST)]

:application_url_nice_label: https://en.wikipedia.org/wiki/Application_software[Application]

:computer_network_url_nice_label: https://en.wikipedia.org/wiki/Computer_network[Computer network]

:data_link_layer_url_nice_label: https://en.wikipedia.org/wiki/Data_link_layer[Data link layer]

:network_layer_url_nice_label: https://en.wikipedia.org/wiki/Network_layer[Network layer]

:computer_url_nice_label: https://en.wikipedia.org/wiki/Computer[Computer]

:computer_appliance_url_nice_label: https://en.wikipedia.org/wiki/Computer_appliance[Computer appliance]

:client_server_url_nice_label: https://en.wikipedia.org/wiki/Client%E2%80%93server_model[Clientâ€“server]

:server_url_nice_label: https://en.wikipedia.org/wiki/Server_(computing)[Server]

:client_url_nice_label: https://en.wikipedia.org/wiki/Client_(computing)[Client]

:microservice_url_nice_label: https://en.wikipedia.org/wiki/Microservices[Microservice]

:high_availability_url_nice_label: https://en.wikipedia.org/wiki/High_availability[High availability]

:timeout_url_nice_label: https://en.wikipedia.org/wiki/Timeout_(computing)[Timeout]

:multitier_architecture_url_nice_label: https://en.wikipedia.org/wiki/Multitier_architecture[Multitier architecture]

:openvpn_url_nice_label: https://en.wikipedia.org/wiki/OpenVPN[OpenVPN]

:replication_url_nice_label: https://en.wikipedia.org/wiki/Replication_(computing)[Replication]

:failover_url_nice_label: https://en.wikipedia.org/wiki/Failover[Failover]

:computer_cluster_url_nice_label: https://en.wikipedia.org/wiki/Computer_cluster[Cluster]

:vrrp_url_nice_label: https://en.wikipedia.org/wiki/Virtual_Router_Redundancy_Protocol[Virtual Router Redundancy Protocol (VRRP)]

:load_balancing_url_nice_label: https://en.wikipedia.org/wiki/Load_balancing_(computing)[Load balancing]

:round_robin_url_nice_label: https://en.wikipedia.org/wiki/Round-robin_scheduling[Round-robin]

:database_url_nice_label: https://en.wikipedia.org/wiki/Database[Database]

:crl_url_nice_label: https://en.wikipedia.org/wiki/Certificate_revocation_list[Certificate revocation list]

:redundancy_url_nice_label: https://en.wikipedia.org/wiki/Redundancy_(engineering)[Redundancy]

:ejbca_url_nice_label: https://en.wikipedia.org/wiki/EJBCA[Enterprise JavaBeans Certificate Authority]

:openssl_url_nice_label: https://en.wikipedia.org/wiki/OpenSSL[OpenSSL]

:gui_url_nice_label: https://en.wikipedia.org/wiki/Graphical_user_interface[Graphical user interface]

:kubernetes_url_nice_label: https://en.wikipedia.org/wiki/Kubernetes[Kubernetes]

:container_url_nice_label: https://en.wikipedia.org/wiki/Containerization_(computing)[Container]

:cloud_url_nice_label: https://en.wikipedia.org/wiki/Cloud_computing[Cloud]

:vm_url_nice_label: https://en.wikipedia.org/wiki/Virtual_machine[Virtual machine]

:alpine_linux_url_nice_label: https://en.wikipedia.org/wiki/Alpine_Linux[Alpine Linux]

:os_url_nice_label: https://en.wikipedia.org/wiki/Operating_system[Operating system]

:example_tls_app_url_nice_label: https://gist.github.com/spikebike/2232102[Example TLS client-server]

:poc_url_nice_label: https://en.wikipedia.org/wiki/Proof_of_concept[Proof of concept]

:ingress_url_nice_label: https://kubernetes.io/docs/concepts/services-networking/ingress[Ingress]

:on_prem_url_nice_label: https://en.wikipedia.org/wiki/On-premises_software[On-premises]

:foss_url_nice_label: https://en.wikipedia.org/wiki/Free_and_open-source_software[FOSS]

:repositor_url_nice_label: https://en.wikipedia.org/wiki/Software_repository[Repository]

:git_url_nice_label: https://en.wikipedia.org/wiki/Git[Git]

// INFO: Parametes section (labels).

:local_user: user
:local_hostname: localhost

:some_source_file_adoc: some_source_file.adoc
:some_source_file_puml: some_source_file.puml

:plantuml_server_name: plantumlserver

= Public-key infrastructure

This document contains description of complex {pki_url_nice_label} solution. All questions related to the content please send to tomasz.orlowski@creotech.pl.

.todo:

* Add Table of content.

== General overview and scope of this document

A {pki_url_nice_label} is a set of roles, policies, hardware, software and procedures needed to create, manage, distribute, use, store and revoke {pub_key_cert_nice_label}s and using {pub_key_crypto_url_nice_label}.

IMPORTANT: This document covers only small subset of extensive {computer_security_url_nice_label} subject and focuses only on technical aspects of the implementation. It is mainly based of {nsc_url_nice_label}, particulary {nsc_800_52_url_nice_label} reated to {nist_url_nice_label}, particulary {nist_800_52_url_nice_label}.

This document covers mainly {tls_url_nice_label} and {vpn_url_nice_label} appraoches and highlights fundamental differences between these two technoogies. Both can be used for secure communication but they differ mainly by area of interest and when/where it should be used.

{tls_url_nice_label} is a {crypt_protocol_url_nice_label} designed to provide communications {computer_security_url_nice_label} over a {computer_network_url_nice_label}, such as the Internet. The {comm_protocol_url_nice_label} is widely used in applications such as email, instant messaging, and voice over IP, but its use in securing {https_url_nice_label} remains the most publicly visible including {rest_url_nice_label} solutions.

The {tls_url_nice_label} protocol aims primarily to provide security, including privacy (confidentiality), integrity, and authenticity through the use of {cryptography_url_nice_label}, such as the use of {pub_key_cert_nice_label}, between two or more communicating computer {application_url_nice_label}s. It runs in the {presentation_layer_url_nice_label} and is itself composed of two layers: the {tls_url_nice_label} record and the {tls_url_nice_label} {handshake_url_nice_label} {comm_protocol_url_nice_label}.

{vpn_url_nice_label} is a {computer_network_url_nice_label} architecture for virtually extending a private network, i.e. any network which is not the public Internet, across one or multiple other networks which are either untrusted or need to be isolated.

A {vpn_url_nice_label} can extend access to a private network to users who do not have direct access to it, such as an office network allowing secure access from off-site over the Internet. This is achieved by creating a link between computing devices and {computer_network_url_nice_label}s by the use of network tunneling protocols using {data_link_layer_url_nice_label} or {network_layer_url_nice_label}, depending on needs.

IMPORTANT: Main differnece between {tls_url_nice_label} and {vpn_url_nice_label} is that {tls_url_nice_label} interconnects securely {application_url_nice_label}s on {presentation_layer_url_nice_label} level while {vpn_url_nice_label} interconnects securely {computer_url_nice_label}s and {computer_appliance_url_nice_label}s on {data_link_layer_url_nice_label} or {network_layer_url_nice_label}.

[plantuml, format="png", id="tls_vs_vpn"]
----
@startuml
scale 1

!include <tupadr3/common>

!include <office/Clouds/cloud_disaster_red>

!include <osa/desktop/desktop>
!include <osa/ics/plc/plc>
!include <osa/laptop/laptop>
!include <osa/desktop/imac/imac>
!include <osa/mobile/pda/pda>

!include <cloudinsight/tomcat>
!include <cloudinsight/kafka>
!include <cloudinsight/java>
!include <cloudinsight/cassandra>

' Used to center the label under the images
skinparam defaultTextAlignment center
skinparam monochrome true

title Difference between TLS and VPN

package "TLS" {
    cloud "<$cloud_disaster_red>\nUntrusted network" as tls_cloud
    rectangle "<$tomcat>\nWebapp" as webapp
    queue "<$kafka>\nKafka" as kafka
    rectangle "<$java>\nDaemon" as daemon
    database "<$cassandra>\nDatabase>" as database

    tls_cloud <-up-> webapp
    tls_cloud <-down-> kafka
    tls_cloud <-down-> daemon
    tls_cloud <-down-> database
}

package "VPN" {
    cloud "<$cloud_disaster_red>\nUntrusted network" as vpn_cloud
    rectangle "<$pda>\nPDA" as pda
    rectangle "<$plc>\nPLC" as plc
    rectangle "<$desktop>\nDesktop" as desktop
    rectangle "<$laptop>\nLaptop" as laptop
    rectangle "<$imac>\nImac" as imac

    vpn_cloud <-up-> pda
    vpn_cloud <-up-> plc
    vpn_cloud <-down-> desktop
    vpn_cloud <-down-> laptop
    vpn_cloud <-down-> imac
}
@enduml
----

== Architecture overview

Both {pki_url_nice_label} solutions described below need to be considered, implemented and utilised.

{tls_url_nice_label} based on {pki_url_nice_label} consist of three main groups:

* <<Certificate Authority>>
* <<TLS Server>>
* <<TLS Client>>

{vpn_url_nice_label} based on {pki_url_nice_label} consist of three main groups:

* <<Certificate Authority>>
* <<VPN Server>>
* <<VPN Client>>

If there is no technical restrictions and/or constraints which are currently unconsidered, one logical shared <<Certificate Authority>> should be used for both {tls_url_nice_label} and {vpn_url_nice_label}. It should be designed and implemented according good practices, especially using {high_availability_url_nice_label} techniques like {redundancy_url_nice_label}.

=== Certificate Authority

In {cryptography_url_nice_label}, a {ca_url_nice_label} is an entity that stores, signs, and issues {pub_key_cert_nice_label}s. A {pub_key_cert_nice_label} proves the ownership of a public key by the named subject of the {pub_key_cert_nice_label}. This allows others (relying parties) to rely upon {digital_signature_url_nice_label} or on assertions made about the private key that corresponds to the certified public key. A {ca_url_nice_label} acts as a {trusted_third_party_url_nice_label} trusted both by the subject (owner) of the {pub_key_cert_nice_label} and by the party relying upon the {pub_key_cert_nice_label}. The format of these certificates is specified by the {x509_url_nice_label} standard.

IMPORTANT: The crucial functionality and privilege of Certificate Authority is <<Certificate revocation>> of issued {pub_key_cert_nice_label} and it is explained why further in this document. Check chapter dedicated to it for more information. In shortcut Certificate Authority is able to ban issued certificate and this way <<TLS Server>> is not able to serve any more.

Example implementation of Certificate Authority is {ejbca_url_nice_label} and it will be used further as a reference in this document. This software was chosen because of using {openssl_url_nice_label} under the hood. It is widely applied and it offers a wide range of features including {pub_key_cert_nice_label} lifecycle management and {gui_url_nice_label}.

=== TLS Server

This is name for {server_url_nice_label} related to {tls_url_nice_label} according to {client_server_url_nice_label} model. TLS server acts as topological central point for several <<TLS Client>>s and is able to manage multiple connections at once. Most common approach and good practice is to locate it inside known area of network, inside premises, and on own managed and trusted environment.

From architecture point of view it acts as known internal resource, where external clients are able to connect to on demand. It should listen and be available all the time so technique like {high_availability_url_nice_label} is applied to achieve this goal. Behind it actual application is located which delivers target buissness logic.

Example is {microservice_url_nice_label} using {rest_url_nice_label} API available in public {computer_network_url_nice_label}.

=== TLS Client

This is name for {client_url_nice_label} related to {tls_url_nice_label} according to {client_server_url_nice_label} model. TLS client acts as one of many topological edge points of central <<TLS Server>> and usually is able to manage only one connection. Most common approach is to locate it outside known area of network and its goal is to be able to establish secure connection with <<TLS Server>> and to get some information from it or to send some information to it.

From architecture point of view it acts as one of external resources, which is able to securely connect to internal <<TLS Server>> on demand. <<TLS Server>> should listen and be available all the time but in practice downtime, network issues or other internal complications can happen. That is why TLS client should be able to reconnect so technique like {timeout_url_nice_label} is applied to achieve this goal. In case of TLS client, before {tls_url_nice_label} tier buissness logic is located which requests some information or data from  <<TLS Server>>.

Example is Front-end requesting via {rest_url_nice_label} API something from Back-end hidden behind <<TLS Server>> located remotely in secure area of network, inside premises. This way TLS client, the untrusted party located in untrusted area of network (for example web browser) is able to get via secure connection some information or data form <<TLS Server>>, the trusted party located in trusted area of network. Such architecural isolation is base concept of security management in {multitier_architecture_url_nice_label}. Such scenario is commonly used and is considered as a good practice.

=== VPN Server

Analogous to <<TLS Server>> this is name for {server_url_nice_label} related to {vpn_url_nice_label} according to {client_server_url_nice_label} model. VPN server acts as topological central point for several <<VPN Client>>s and is able to manage multiple connections at once. Also like <<TLS Server>> most common approach and good practice is to locate it inside known area of network, inside premises, and on own managed and trusted environment.

From architecture point of view it acts as known internal resource, where external clients are able to connect to on demand. Behind it whole or some subset of remote (or isolated) {computer_network_url_nice_label} is located and accessible.

Example implementation of {vpn_url_nice_label} is {openvpn_url_nice_label} and it will be used further as a reference in this document. This implementation was chosen because of being well known, widely applied, and having support of {ca_url_nice_label} and {x509_url_nice_label} {pub_key_cert_nice_label}s integration.

VPN Server should listen and be available all the time. {openvpn_url_nice_label} server {replication_url_nice_label} typically refers to either {failover_url_nice_label} or {computer_cluster_url_nice_label}ing setups for {high_availability_url_nice_label}. In a {failover_url_nice_label} setup, a primary server has a standby secondary server that automatically takes over if the primary fails, using {vrrp_url_nice_label}. In a {computer_cluster_url_nice_label} setup, multiple servers simultaneously handle <<VPN Client>> connections using {load_balancing_url_nice_label} strategy based on {round_robin_url_nice_label} algorithm, with configurations stored in a central {database_url_nice_label} common for all instances. <<VPN Client>>s connect to any available instance. 

=== VPN Client

Analogous to <<TLS Client>> this is name for {client_url_nice_label} related to {vpn_url_nice_label} according to {client_server_url_nice_label} model. VPN client acts as one of many topological edge points of central <<VPN Server>> and usually is able to manage only one connection. Also like <<TLS Client>> most common approach is to locate it outside known area of network.

From architecture point of view it acts as one of external resources, which is able to securely connect to internal <<VPN Server>> on demand. <<VPN Server>> should listen and be available all the time but in practice downtime, network issues or other internal complications can happen. That is why VPN client should be able to reconnect so technique like {timeout_url_nice_label} is applied to achieve this goal.

In case of VPN client, before {vpn_url_nice_label} tier whole or some subset of {computer_network_url_nice_label} is located. Its goal is to be able to establish secure connection with <<VPN Server>> and to obtain access to remote or isolated {computer_network_url_nice_label} hidden behind that server.

=== Establishing a SSL/TLS Session

{tls_url_nice_label} is used for secure communication between the <<TLS Client>> side and <<TLS Server>> side in the {presentation_layer_url_nice_label}. Simplified connection establishment is presented in the diagram below.

[plantuml, format="png", id="simplified_tls_connection_establishment"]
----
@startuml

participant "TLS Client" as client
participant "TLS Server" as server

group Secure connection establishment
client -> server: Hello. I want to establish secure connection with you, because I know who you are.
server -> client: Hello. I know who you are too so sure, let's do it.
end

group Secure connection
client <-> server: Secure bidirectional data exchange
end

@enduml
----

Always <<TLS Client>> initializates connection by sending "hello" message to the <<TLS Server>>. In practice, this process can be more complicated and indeed it is. It consist of two parts: the handshake and actual secure session. The main complication is making sure, that both sides know each ohter. Diagram below presents more advanced overview of the process.

[plantuml, format="png", id="advanced_tls_connection_establishment"]
----
@startuml

actor User
participant "TLS Client" as client
participant "TLS Server" as server

User->client: Start secure session

group TCP
client->server: SYN
server->client: SYN ACK
client->server: ACK
end

group TLS handshake (unencrypted part)
client->server: ClientHello
server->client: ServerHello
server->client: ServerCertyficate (authentication)
server->client: ServerHelloDone
client->server: ClientKeyExchange Message
client->server: ChangeCipherSpec
client->server: Finished
server->client: ChangeCipherSpec
server->client: Finished
end

group TLS session (encrypted part)
client<->server: Secure bidirectional data exchange
end

@enduml
----

This communication can differ in many ways depending on the configuration applied. Good practices are described in {nsc_800_52_url_nice_label} based on  {nist_800_52_url_nice_label}. Detailed configuration aspects are not important for understanding the general building blocks of the architecture and is out of scope of this document.

The important detail in the diagram presented is described as authentication. The <<TLS Client>> verifies the <<TLS Server>>'s {pub_key_cert_nice_label} with the <<Certificate Authority>> that issued it. This confirms that the <<TLS Server>> is who it says it is, and that the <<TLS Client>> is interacting with the actual owner of the domain. Here comes the <<Certificate Authority>> as important player in {tls_url_nice_label} handshake, which is essencial in secure communication establishment.

As mentioned during establishing a SSL/TLS session the <<TLS Client>> verifies the <<TLS Server>>'s {pub_key_cert_nice_label} with the <<Certificate Authority>> that issued it. This confirms that the <<TLS Server>> is who it says it is but also verifies if the <<TLS Server>> is still allowed to serve for the <<TLS Client>>. Permission is granted to the <<TLS Server>> via <<Certificate Authority>> and it can be also revoked by <<Certificate Authority>> before such granted <<TLS Server>>'s {pub_key_cert_nice_label} has expired. Check <<Certificate revocation>> for more details.

NOTE: Similar scenario takes place in case of {vpn_url_nice_label} using {pki_url_nice_label} utilizing <<Certificate Authority>> and {pub_key_cert_nice_label}. There are some differences which are not relevant in this context. Most important is that <<Certificate Authority>> is able to ban issued for <<VPN Server>> certifiacte, which unables secure connection to be esatblished.

=== Certificate revocation

In {pub_key_crypto_url_nice_label}, a {pub_key_cert_nice_label} may be revoked before it expires, which signals that it is no longer valid. Without revocation, an attacker could exploit such a compromised or misissued certificate until expiry. Hence, revocation is an important part of a public key infrastructure. Revocation is performed by the issuing <<Certificate Authority>>, which produces a cryptographically authenticated statement of revocation like {crl_url_nice_label}. This information need to be distributed to proper parts of {pki_url_nice_label} but this is not relevant and is out of the scope of this document.

// INFO: Page separator
[%always]
<<<

== What is needed

To implement properly {pki_url_nice_label}, especially in {cloud_url_nice_label} native {kubernetes_url_nice_label} distributed environemnt, several separated {container_url_nice_label}s need to be available.

IMPORTANT: For proper {container_url_nice_label} {replication_url_nice_label}, {vm_url_nice_label}s for {database_url_nice_label}s need to be used but this is out of the scope of this document and will be not mentioned in the diagrams.

Proper containers need to be visable to each other, depending on their role. Inter-commentions on virtual {computer_network_url_nice_label} need to be supported. 

The main assumptions are:

* <<Certificate Authority>> is common for both {tls_url_nice_label} and {vpn_url_nice_label} solutions.
* Lightweight {alpine_linux_url_nice_label} is proposed to be used by default in containers as an {os_url_nice_label} because of its small footprint and security-oriented design but it is not mandatory.
* Container in this context can mean physically set of containers to provide {replication_url_nice_label}. For simplicity it is threated as one logic instance and is called simply as container.
* Minimal amount of TCP and UDP ports needed should be exposed in each of container and available for rest components of the system.
* <<TLS Server>> and <<TLS Client>> should be threated only as placeholders and any example code like {example_tls_app_url_nice_label} can be used as a{poc_url_nice_label}.
* Proper {ingress_url_nice_label} configuration need to be provided where applicable and mandatory according good practices.
* {load_balancing_url_nice_label} considerations should be taken under part where applicable and mandatory according good practices.

IMPORTANT: Described solution is due to be mirrored in the internal {on_prem_url_nice_label} resporces for security audits and performance testing. It is crucial to get all needed sources applied in form of {git_url_nice_label} {repositor_url_nice_label} including Dockerfiles and Ansible cookbooks. {foss_url_nice_label} solutions are recommended to avoid any legal issues realated to the ownership.

From architectural point of view, containers listed below are needed:

* Container for <<Certificate Authority>> consisting of {ejbca_url_nice_label} and configuration according to best practices.
* Container for <<TLS Server>> consisting of {example_tls_app_url_nice_label} server part and configuration according to {nist_800_52_url_nice_label}.
* Container for <<TLS Client>> consisting of {example_tls_app_url_nice_label} client part and configuration according to {nist_800_52_url_nice_label}.
* Container for <<VPN Server>> consisting of {openvpn_url_nice_label} and configuration according to best practices.
* Container for <<VPN Client>> consisting of {openvpn_url_nice_label} and configuration according to best practices.
* Additional containers for {ingress_url_nice_label} and {load_balancing_url_nice_label} if applicable and mandatory for atomic and isolated {poc_url_nice_label}.

Diagram below presents conceptual topology of network edges between components of the {pki_url_nice_label}.

.todo:

* Draw diagram presenting inter-connections.


.todo:
* Ansible albo terraform.
* For rapid provisioning automated ansible kookbooks need to be provided.
* Write that each Dockerfile and related configuration files are needed in form of repository for environment replication, testing and audits.

.todo:

* Virtual Machine with USB for RootCA.
* Underline what parts need to be physical.

== VS Code developer manual

List of useful {vscode_url_nice_label} extentions used for development:

* AsciiDoc
* PlantUML Viewer
* Docker

=== AsciiDoc

If you want to see generated `{some_source_file_adoc}` preview open file you are interrested in and press `ctrl+shift+v` key combination. New window should appear containing your generated `{some_source_file_adoc}` preview.

=== PlantUML Viewer

If you want to see generated `{some_source_file_puml}` preview open file you are interrested in and press `alt+d` key combination. Preview window should appear next to your `{some_source_file_puml}` code.

=== Docker

Docker extension is used only to see currently running images. It is not mandatory. It is possible to check status of running PlantUML server docker image via CLI. Check section dedicated to <<PlantUML Server>> for details.

== PlantUML Server

According to the README article {asciidoctor_plantuml_url_nice_label} PlantUML Server can be launched locally in {docker_url_nice_label} via command line.

[subs="+attributes"]
-------------------------------------------------------------------------------
docker run -d --name {plantuml_server_name} -p 8081:8080 plantuml/plantuml-server:jetty
f12e5651ee03a2f53fe6cc5d21529d5ef0611005a4a46f66aa5c4f29e9ed4528
-------------------------------------------------------------------------------

You can verify if PlantUML Server {docker_url_nice_label} container is already running from command line.

[subs="+attributes"]
-------------------------------------------------------------------------------
[{local_user}@{local_hostname} ~]$ docker ps --format '{{.Names}}' | grep {plantuml_server_name}
{plantuml_server_name}
-------------------------------------------------------------------------------

If command gives empty output, probably container is not running.

// INFO: Page separator
[%always]
<<<

== Source of information

* https://www.cloudflare.com/pl-pl/learning/ssl/what-happens-in-a-tls-handshake[What happens in a TLS handshake?]
* https://developer.okta.com/books/api-security/tls/how[Establishing a SSL/TLS Session]
* https://www.researchgate.net/figure/The-TLS-handshake-protocol-messages-sequence_fig2_321580115[The TLS handshake protocol messages sequence]

// INFO: Page separator
[%always]
<<<

== TODO and action points for future

Items planned to be added or extended:

* Integrate automated spell checking like {hunspell_url_nice_label} based od vanilla dictionary and add local dictionary (related to this article) to it.
* Integrate conditional PDF generation depending on profiles (ie. custommer, architect, developer, all, etc...). Add profiles and generate in separate directories each profile separately. Profiles need to be parsed automaticly based on comments next to titles as comments.
* Implement redundant/unused parameters detection and rise build error for that.
* Implement unknown parameters detector and rise build error for that.
* Implement proper PDF generator for PlantUML diagrams. Source of information: https://fiveandahalfstars.ninja/blog/2017/2017-05-01-plantuml-and-pdf
