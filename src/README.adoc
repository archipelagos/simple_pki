// INFO: Parametes section (URLs).
:pki_url_nice_label: https://en.wikipedia.org/wiki/Public_key_infrastructure[Public-key infrastructure (PKI)]

:pub_key_cert_nice_label: https://en.wikipedia.org/wiki/Public_key_certificate[Public-key certificate]

:hunspell_url_nice_label: https://en.wikipedia.org/wiki/Hunspell[Hunspell]

:pub_key_crypto_url_nice_label: https://en.wikipedia.org/wiki/Public-key_cryptography[Public-key cryptography]

:vscode_url_nice_label: https://en.wikipedia.org/wiki/Visual_Studio_Code[Visual Studio Code]

:asciidoctor_plantuml_url_nice_label: https://github.com/hsanson/asciidoctor-plantuml?tab=readme-ov-file#docker[PlantUML Server]

:docker_url_nice_label: https://en.wikipedia.org/wiki/Docker_(software)[Docker]

:computer_security_url_nice_label: https://en.wikipedia.org/wiki/Computer_security[Computer security]

:nsc_url_nice_label: https://www.gov.pl/web/baza-wiedzy/narodowe-standardy-cyber[Polish National Cybersecurity Standards]

:nsc_800_52_url_nice_label: https://www.gov.pl/attachment/e3804a73-2d3e-4232-bc6d-9bbb4ba697bb[Guidelines for the Selection, Configuration, and Use of Transport Layer Security (TLS) Implementations called NSC 800-52 published on December 2023]

:nist_url_nice_label: https://www.nist.gov[National Institute of Standards and Technology]

:nist_800_52_url_nice_label: https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-52r2.pdf[Guidelines for the Selection, Configuration, and Use of Transport Layer Security (TLS) Implementations called NIST Special Publication 800-52 Revision 2 published in August 2019]

:tls_url_nice_label: https://en.wikipedia.org/wiki/Transport_Layer_Security[Transport Layer Security (TLS)]

:crypt_protocol_url_nice_label: https://en.wikipedia.org/wiki/Cryptographic_protocol[Cryptographic protocol]

:comm_protocol_url_nice_label: https://en.wikipedia.org/wiki/Communication_protocol[Communication protocol]

:cryptography_url_nice_label: https://en.wikipedia.org/wiki/Cryptography[Cryptography]

:present_layer_url_nice_label: https://en.wikipedia.org/wiki/Presentation_layer[Presentation layer]

:handshake_url_nice_label: https://en.wikipedia.org/wiki/Handshake_(computing)[Handshake]

:ca_url_nice_label: https://en.wikipedia.org/wiki/Certificate_authority[Certificate authority]

:x509_url_nice_label: https://en.wikipedia.org/wiki/X.509[X.509]

:digital_signature_url_nice_label: https://en.wikipedia.org/wiki/Digital_signature[Digital signature]

:trusted_third_party_url_nice_label: https://en.wikipedia.org/wiki/Trusted_third_party[Trusted third party]

:vpn_url_nice_label: https://en.wikipedia.org/wiki/Virtual_private_network[Virtual private network]

:https_url_nice_label: https://en.wikipedia.org/wiki/HTTPS[Hypertext Transfer Protocol Secure (HTTPS)

// INFO: Parametes section (labels).

:local_user: user
:local_hostname: localhost

:some_source_file_adoc: some_source_file.adoc
:some_source_file_puml: some_source_file.puml

:plantuml_server_name: plantumlserver

= Public-key infrastructure

This repository contains complex {pki_url_nice_label} solution with detailed description. All questions related to the content please send to tomasz.orlowski@creotech.pl.

== General overview and scope of this document

A {pki_url_nice_label} is a set of roles, policies, hardware, software and procedures needed to create, manage, distribute, use, store and revoke {pub_key_cert_nice_label}s and using {pub_key_crypto_url_nice_label}.

IMPORTANT: This document covers only small subset of extensive {computer_security_url_nice_label} subject and focuses only on technical aspects of the implementation. It is mainly based of {nsc_url_nice_label}, particulary {nsc_800_52_url_nice_label} reated to {nist_url_nice_label}, particulary {nist_800_52_url_nice_label}.

This document covers mainly {tls_url_nice_label}. Further sections introduce {vpn_url_nice_label} appraoch and highlights fundamental differences between these two technoogies. Both can be used for secure communication but they differ mainly by area of interest and when/where it should be used.

{tls_url_nice_label} is a {crypt_protocol_url_nice_label} designed to provide communications {computer_security_url_nice_label} over a computer network, such as the Internet. The {comm_protocol_url_nice_label} is widely used in applications such as email, instant messaging, and voice over IP, but its use in securing {https_url_nice_label} remains the most publicly visible. 

The {tls_url_nice_label} protocol aims primarily to provide security, including privacy (confidentiality), integrity, and authenticity through the use of {cryptography_url_nice_label}, such as the use of {pub_key_cert_nice_label}, between two or more communicating computer applications. It runs in the {present_layer_url_nice_label} and is itself composed of two layers: the {tls_url_nice_label} record and the {tls_url_nice_label} {handshake_url_nice_label} {comm_protocol_url_nice_label}.

.todo:

* VPN - write what is that in this article and on what layer it is used.
* Highlight what is not by default included to VPN vs TLS.
* Include diagram presenting layers and where TLS vs VPN is located.

== General solution architecture description

{tls_url_nice_label} based on {pki_url_nice_label} consist of three main groups:

* <<Certificate Authority>>
* <<TLS Server>>
* <<TLS Client>>

.todo:

* Add the same form about VPN and write main groups with additional sections for it.

=== Certificate Authority

In {cryptography_url_nice_label}, a {ca_url_nice_label} is an entity that stores, signs, and issues {pub_key_cert_nice_label}s. A {pub_key_cert_nice_label} proves the ownership of a public key by the named subject of the {pub_key_cert_nice_label}. This allows others (relying parties) to rely upon {digital_signature_url_nice_label} or on assertions made about the private key that corresponds to the certified public key. A {ca_url_nice_label} acts as a {trusted_third_party_url_nice_label} trusted both by the subject (owner) of the {pub_key_cert_nice_label} and by the party relying upon the {pub_key_cert_nice_label}. The format of these certificates is specified by the {x509_url_nice_label} standard.

.todo:

* Add paragraph about revoke {pub_key_cert_nice_label}s and why it is imporatnt from our point of view.

=== TLS Server

.todo:

* Write short description what is server in TLS.

=== TLS Client

.todo:

* Write short description what is client in TLS.

=== Establishing a SSL/TLS Session

{tls_url_nice_label} is used for secure communication between the <<TLS Client>> side and <<TLS Server>> side in the {present_layer_url_nice_label}. Simplified connection establishment is presented in the diagram below.

[plantuml, format="png", id="simplified_tls_connection_establishment"]
----
@startuml

participant "TLS Client" as client
participant "TLS Server" as server

group Secure connection establishment
client -> server: Hello. I want to establish secure connection with you, because I know who you are.
server -> client: Hello. I know who you are too so sure, let's do it.
end

group Secure connection
client <-> server: Secure bidirectional data exchange
end

@enduml
----

Always <<TLS Client>> initializates connection by sending "hello" message to the <<TLS Server>>. In practice, this process can be more complicated and indeed it is. It consist of two parts: the handshake and actual secure session. The main complication is making sure, that both sides know each ohter. Diagram below presents more advanced overview of the process.

[plantuml, format="png", id="relation_to_ca"]
----
@startuml

actor User
participant "TLS Client" as client
participant "TLS Server" as server

User->client: Start secure session

group TCP
client->server: SYN
server->client: SYN ACK
client->server: ACK
end

group TLS handshake (unencrypted part)
client->server: ClientHello
server->client: ServerHello
server->client: ServerCertyficate (authentication)
server->client: ServerHelloDone
client->server: ClientKeyExchange Message
client->server: ChangeCipherSpec
client->server: Finished
server->client: ChangeCipherSpec
server->client: Finished
end

group TLS session (encrypted part)
client<->server: Secure bidirectional data exchange
end

@enduml
----

This communication can differ in many ways depending on the configuration applied. Good practices are described in {nsc_800_52_url_nice_label} based on  {nist_800_52_url_nice_label}. Detailed configuration aspects are not important for understanding the general building blocks of the architecture and is out of scope of this document.

The important detail in the diagram presented is described as authentication. The <<TLS Client>> verifies the <<TLS Server>>'s {pub_key_cert_nice_label} with the <<Certificate Authority>> that issued it. This confirms that the <<TLS Server>> is who it says it is, and that the <<TLS Client>> is interacting with the actual owner of the domain. Here comes the <<Certificate Authority>> as important player in {tls_url_nice_label} handshake, which is essencial in secure communication establishment.

.todo:

* Add paragraph about certificate revocation here and underline, why it is important.

// INFO: Page separator
[%always]
<<<

== VS Code developer manual

List of useful {vscode_url_nice_label} extentions used for development:

* AsciiDoc
* PlantUML Viewer
* Docker

=== AsciiDoc

If you want to see generated `{some_source_file_adoc}` preview open file you are interrested in and press `ctrl+shift+v` key combination. New window should appear containing your generated `{some_source_file_adoc}` preview.

=== PlantUML Viewer

If you want to see generated `{some_source_file_puml}` preview open file you are interrested in and press `alt+d` key combination. Preview window should appear next to your `{some_source_file_puml}` code.

=== Docker

Docker extension is used only to see currently running images. It is not mandatory. It is possible to check status of running PlantUML server docker image via CLI. Check section dedicated to <<PlantUML Server>> for details.

== PlantUML Server

According to the README article {asciidoctor_plantuml_url_nice_label} PlantUML Server can be launched locally in {docker_url_nice_label} via command line.

[subs="+attributes"]
-------------------------------------------------------------------------------
docker run -d --name {plantuml_server_name} -p 8081:8080 plantuml/plantuml-server:jetty
f12e5651ee03a2f53fe6cc5d21529d5ef0611005a4a46f66aa5c4f29e9ed4528
-------------------------------------------------------------------------------

You can verify if PlantUML Server {docker_url_nice_label} container is already running from command line.

[subs="+attributes"]
-------------------------------------------------------------------------------
[{local_user}@{local_hostname} ~]$ docker ps --format '{{.Names}}' | grep {plantuml_server_name}
{plantuml_server_name}
-------------------------------------------------------------------------------

If command gives empty output, probably container is not running.

// INFO: Page separator
[%always]
<<<

== Source of information

* https://www.cloudflare.com/pl-pl/learning/ssl/what-happens-in-a-tls-handshake[What happens in a TLS handshake?]
* https://developer.okta.com/books/api-security/tls/how[Establishing a SSL/TLS Session]
* https://www.researchgate.net/figure/The-TLS-handshake-protocol-messages-sequence_fig2_321580115[The TLS handshake protocol messages sequence]

// INFO: Page separator
[%always]
<<<

== TODO

Items planned to be added or extended:

.todo:
* Integrate spell checking like {hunspell_url_nice_label}.
* Integrate conditional PDF generation depending on profiles (ie. custommer, architect, developer, all, etc...).
* Implement redundant/unused parameters detection.
* Implement unknown parameters detector and rise build error for that.
* Implement proper PDF generator for PlantUML diagrams. Source of information: https://fiveandahalfstars.ninja/blog/2017/2017-05-01-plantuml-and-pdf
